<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å•†å“é”€é‡åˆ†æç³»ç»Ÿ - Century Business</title>
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸ“Š</text></svg>">
    <!-- ä¾èµ–åº“ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- React for Analysis System -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #ffffff;
            min-height: 100vh;
            color: #1e293b;
        }

        #root {
            min-height: 100vh;
            padding: 32px;
        }

        #root * {
            box-sizing: border-box;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script>
        // åŸç”Ÿ Canvas å›¾è¡¨ç»„ä»¶
        const CanvasLineChart = ({ data, width = 800, height = 300, color = '#3b82f6', label = 'é”€é‡' }) => {
            const { useRef, useEffect } = React;
            const canvasRef = useRef(null);
            
            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas || !data || data.length === 0) return;
                
                const ctx = canvas.getContext('2d');
                const padding = 60;
                const chartWidth = width - padding * 2;
                const chartHeight = height - padding * 2;
                
                // æ¸…ç©ºç”»å¸ƒ
                ctx.clearRect(0, 0, width, height);
                
                // è®¡ç®—æ•°æ®èŒƒå›´
                const values = data.map(d => d.quantity || d.revenue || 0);
                const maxValue = Math.max(...values, 1);
                const minValue = Math.min(...values, 0);
                const range = maxValue - minValue || 1;
                
                // ç»˜åˆ¶ç½‘æ ¼
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 5; i++) {
                    const y = padding + (chartHeight / 5) * i;
                    ctx.beginPath();
                    ctx.moveTo(padding, y);
                    ctx.lineTo(width - padding, y);
                    ctx.stroke();
                }
                
                // ç»˜åˆ¶åæ ‡è½´
                ctx.strokeStyle = '#94a3b8';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(padding, padding);
                ctx.lineTo(padding, height - padding);
                ctx.lineTo(width - padding, height - padding);
                ctx.stroke();
                
                // ç»˜åˆ¶æŠ˜çº¿ï¼ˆä¸ç»˜åˆ¶ç‚¹ï¼‰
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                ctx.beginPath();
                
                data.forEach((item, index) => {
                    const x = padding + (chartWidth / (data.length - 1 || 1)) * index;
                    const value = item.quantity || item.revenue || 0;
                    const y = height - padding - ((value - minValue) / range) * chartHeight;
                    
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                
                ctx.stroke();
                
                // ç»˜åˆ¶æ ‡ç­¾
                ctx.fillStyle = '#64748b';
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'center';
                data.forEach((item, index) => {
                    const x = padding + (chartWidth / (data.length - 1 || 1)) * index;
                    ctx.fillText(item.date || '', x, height - padding + 20);
                });
                
                // Yè½´æ ‡ç­¾
                ctx.textAlign = 'right';
                ctx.fillStyle = '#64748b';
                for (let i = 0; i <= 5; i++) {
                    const value = minValue + (range / 5) * (5 - i);
                    const y = padding + (chartHeight / 5) * i;
                    ctx.fillText(Math.round(value).toString(), padding - 10, y + 4);
                }
            }, [data, width, height, color]);
            
            return React.createElement('canvas', { 
                ref: canvasRef, 
                width: width, 
                height: height,
                style: { maxWidth: '100%', height: 'auto' }
            });
        };
        
        const CanvasBarChart = ({ data, width = 800, height = 300, color = '#8b5cf6', label = 'é”€é‡', horizontal = false }) => {
            const { useRef, useEffect } = React;
            const canvasRef = useRef(null);
            
            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas || !data || data.length === 0) return;
                
                const ctx = canvas.getContext('2d');
                // æ¨ªå‘æŸ±çŠ¶å›¾éœ€è¦æ›´å¤šå·¦ä¾§ç©ºé—´æ¥æ˜¾ç¤ºæ ‡é¢˜
                // æ ¹æ®æ•°æ®ä¸­æœ€é•¿æ ‡é¢˜åŠ¨æ€è®¡ç®—å·¦ä¾§padding
                let maxLabelLength = 0;
                if (horizontal && data.length > 0) {
                    data.forEach(item => {
                        const label = item.name || '';
                        maxLabelLength = Math.max(maxLabelLength, label.length);
                    });
                }
                const leftPadding = horizontal ? Math.min(Math.max(maxLabelLength * 7 + 20, 250), 400) : 60;
                const rightPadding = 60;
                const topPadding = 60;
                const bottomPadding = 60;
                const padding = horizontal ? leftPadding : 60;
                const chartWidth = width - leftPadding - rightPadding;
                const chartHeight = height - topPadding - bottomPadding;
                
                ctx.clearRect(0, 0, width, height);
                
                const values = data.map(d => d.quantity || 0);
                const maxValue = Math.max(...values, 1);
                const barWidth = horizontal ? chartHeight / data.length : chartWidth / data.length;
                const barSpacing = barWidth * 0.2;
                const actualBarWidth = barWidth - barSpacing;
                
                // ç»˜åˆ¶ç½‘æ ¼
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 5; i++) {
                    if (horizontal) {
                        const x = leftPadding + (chartWidth / 5) * i;
                        ctx.beginPath();
                        ctx.moveTo(x, topPadding);
                        ctx.lineTo(x, height - bottomPadding);
                        ctx.stroke();
                    } else {
                        const y = padding + (chartHeight / 5) * i;
                        ctx.beginPath();
                        ctx.moveTo(padding, y);
                        ctx.lineTo(width - padding, y);
                        ctx.stroke();
                    }
                }
                
                // ç»˜åˆ¶åæ ‡è½´
                ctx.strokeStyle = '#94a3b8';
                ctx.lineWidth = 2;
                ctx.beginPath();
                if (horizontal) {
                    ctx.moveTo(leftPadding, topPadding);
                    ctx.lineTo(leftPadding, height - bottomPadding);
                    ctx.lineTo(width - rightPadding, height - bottomPadding);
                } else {
                    ctx.moveTo(padding, padding);
                    ctx.lineTo(padding, height - padding);
                    ctx.lineTo(width - padding, height - padding);
                }
                ctx.stroke();
                
                // ç»˜åˆ¶æŸ±çŠ¶å›¾
                data.forEach((item, index) => {
                    const value = item.quantity || 0;
                    const barHeight = (value / maxValue) * chartHeight;
                    
                    if (horizontal) {
                        const y = topPadding + barWidth * index + barSpacing / 2;
                        const barLength = (value / maxValue) * chartWidth;
                        
                        ctx.fillStyle = color;
                        ctx.fillRect(leftPadding, y, barLength, actualBarWidth);
                        
                        // æ ‡ç­¾ - æ˜¾ç¤ºå®Œæ•´æ ‡é¢˜ï¼Œä¸æˆªæ–­
                        ctx.fillStyle = '#64748b';
                        ctx.font = '12px sans-serif';
                        ctx.textAlign = 'right';
                        const label = item.name || '';
                        // è®¡ç®—å¯æ˜¾ç¤ºçš„æœ€å¤§å­—ç¬¦æ•°ï¼ˆæ ¹æ®å·¦ä¾§paddingï¼‰
                        const maxChars = Math.floor((leftPadding - 20) / 7);
                        let displayLabel = label;
                        if (label.length > maxChars) {
                            displayLabel = label.substring(0, maxChars - 3) + '...';
                        }
                        ctx.fillText(displayLabel, leftPadding - 10, y + actualBarWidth / 2 + 4);
                    } else {
                        const x = padding + barWidth * index + barSpacing / 2;
                        
                        ctx.fillStyle = color;
                        ctx.fillRect(x, height - padding - barHeight, actualBarWidth, barHeight);
                        
                        // æ ‡ç­¾
                        ctx.fillStyle = '#94a3b8';
                        ctx.font = '12px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillText(item.name || '', x + actualBarWidth / 2, height - padding + 20);
                    }
                });
                
                // Yè½´æ ‡ç­¾
                ctx.fillStyle = '#94a3b8';
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'right';
                for (let i = 0; i <= 5; i++) {
                    const value = (maxValue / 5) * (5 - i);
                    if (horizontal) {
                        const x = leftPadding + (chartWidth / 5) * i;
                        ctx.fillText(Math.round(value).toString(), x - 10, height - bottomPadding + 4);
                    } else {
                        const y = padding + (chartHeight / 5) * i;
                        ctx.fillText(Math.round(value).toString(), padding - 10, y + 4);
                    }
                }
            }, [data, width, height, color, horizontal]);
            
            return React.createElement('canvas', { 
                ref: canvasRef, 
                width: width, 
                height: height,
                style: { maxWidth: '100%', height: 'auto' }
            });
        };

        // é¥¼çŠ¶å›¾ç»„ä»¶
        const CanvasPieChart = ({ data, width = 600, height = 400 }) => {
            const { useRef, useEffect } = React;
            const canvasRef = useRef(null);
            
            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas || !data || data.length === 0) return;
                
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, width, height);
                
                // è®¡ç®—æ€»å’Œ
                const total = data.reduce((sum, item) => sum + (item.quantity || 0), 0);
                if (total === 0) return;
                
                // é¥¼å›¾ä¸­å¿ƒä½ç½®å’ŒåŠå¾„ - ä¸ºå›¾ä¾‹ç•™å‡ºæ›´å¤šç©ºé—´
                const centerX = width / 2;
                const centerY = height / 2 - 40;
                const radius = Math.min(width, height) / 2 - 120;
                
                // é¢œè‰²æ•°ç»„
                const colors = [
                    '#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6',
                    '#ec4899', '#06b6d4', '#84cc16', '#f97316', '#6366f1',
                    '#14b8a6', '#a855f7', '#f43f5e', '#0ea5e9', '#22c55e'
                ];
                
                let currentAngle = -Math.PI / 2; // ä»é¡¶éƒ¨å¼€å§‹
                
                // ç»˜åˆ¶é¥¼å›¾
                data.forEach((item, index) => {
                    const value = item.quantity || 0;
                    const sliceAngle = (value / total) * 2 * Math.PI;
                    
                    // ç»˜åˆ¶æ‰‡å½¢
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + sliceAngle);
                    ctx.closePath();
                    ctx.fillStyle = colors[index % colors.length];
                    ctx.fill();
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // ç»˜åˆ¶æ ‡ç­¾å’Œæ•°å€¼
                    const labelAngle = currentAngle + sliceAngle / 2;
                    const labelX = centerX + Math.cos(labelAngle) * (radius * 0.7);
                    const labelY = centerY + Math.sin(labelAngle) * (radius * 0.7);
                    
                    // å¦‚æœæ‰‡å½¢è¶³å¤Ÿå¤§ï¼Œåœ¨å†…éƒ¨æ˜¾ç¤ºç™¾åˆ†æ¯”
                    if (sliceAngle > 0.1) {
                        ctx.fillStyle = '#ffffff';
                        ctx.font = 'bold 12px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        const percentage = ((value / total) * 100).toFixed(1);
                        ctx.fillText(percentage + '%', labelX, labelY);
                    }
                    
                    // ç»˜åˆ¶å›¾ä¾‹ - åˆ†ä¸¤åˆ—æ˜¾ç¤º
                    const itemsPerColumn = Math.ceil(data.length / 2);
                    const columnIndex = index < itemsPerColumn ? 0 : 1;
                    const rowIndex = index < itemsPerColumn ? index : index - itemsPerColumn;
                    
                    const legendX = columnIndex === 0 ? 50 : width / 2 + 20;
                    const legendY = 60 + rowIndex * 25;
                    const legendColor = colors[index % colors.length];
                    
                    // å›¾ä¾‹é¢œè‰²å—
                    ctx.fillStyle = legendColor;
                    ctx.fillRect(legendX, legendY - 8, 12, 12);
                    ctx.strokeStyle = '#e2e8f0';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(legendX, legendY - 8, 12, 12);
                    
                    // å›¾ä¾‹æ–‡å­— - æ ¼å¼ï¼šå°ºç å€¼ (æ•°é‡)
                    ctx.fillStyle = '#1e293b';
                    ctx.font = '12px sans-serif';
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'middle';
                    const label = item.name || '';
                    ctx.fillText(`${label} (${value})`, legendX + 18, legendY);
                    
                    currentAngle += sliceAngle;
                });
            }, [data, width, height]);
            
            return React.createElement('canvas', { 
                ref: canvasRef, 
                width: width, 
                height: height,
                style: { maxWidth: '100%', height: 'auto' }
            });
        };

        // åˆ†æç³»ç»ŸReactç»„ä»¶
        const { useState, useMemo } = React;

        // é¢œè‰²ä»£ç æ˜ å°„è¡¨
        const COLOR_MAP = {
            'BLK': 'é»‘è‰²', 'WHT': 'ç™½è‰²', 'RED': 'çº¢è‰²', 'BLU': 'è“è‰²', 'GRN': 'ç»¿è‰²',
            'YEL': 'é»„è‰²', 'ORG': 'æ©™è‰²', 'PNK': 'ç²‰è‰²', 'PUR': 'ç´«è‰²', 'GRY': 'ç°è‰²',
            'BRN': 'æ£•è‰²', 'BGE': 'ç±³è‰²', 'NVY': 'è—é’', 'GLD': 'é‡‘è‰²', 'SLV': 'é“¶è‰²',
            'BBLC': 'é»‘è“', 'WGRY': 'ç™½ç°', 'RBLK': 'çº¢é»‘', 'BWHT': 'è“ç™½', 'GBLK': 'ç»¿é»‘'
        };

        // ä¸å†éœ€è¦ Rechartsï¼Œä½¿ç”¨åŸç”Ÿ Canvas ç»„ä»¶

        const SalesAnalysisSystem = () => {
            console.log('SalesAnalysisSystem ç»„ä»¶å¼€å§‹æ¸²æŸ“ - ä½¿ç”¨åŸç”Ÿ Canvas ç‰ˆæœ¬');
            
            const [data, setData] = useState([]);
            const [filters, setFilters] = useState({
                style: '',
                color: '',
                size: '',
                startDate: '',
                endDate: '',
                timeGranularity: 'day'
            });
            const [showFilters, setShowFilters] = useState(false);
            const [uploadStatus, setUploadStatus] = useState({ type: 'idle', message: '' }); // idle, loading, success, error

            // è§£æSKUè·å–é¢œè‰²
            const parseColor = (sku) => {
                if (!sku) return 'æœªçŸ¥';
                const parts = sku.split('-');
                if (parts.length >= 2) {
                    const colorCode = parts[1].toUpperCase();
                    return COLOR_MAP[colorCode] || colorCode;
                }
                return 'æœªçŸ¥';
            };

            // å¤„ç†æ–‡ä»¶ä¸Šä¼ 
            const handleFileUpload = (e) => {
                console.log('æ–‡ä»¶ä¸Šä¼ äº‹ä»¶è§¦å‘');
                const file = e.target.files[0];
                if (!file) {
                    console.warn('æ²¡æœ‰é€‰æ‹©æ–‡ä»¶');
                    setUploadStatus({ type: 'error', message: 'æœªé€‰æ‹©æ–‡ä»¶' });
                    return;
                }

                console.log('é€‰æ‹©çš„æ–‡ä»¶:', file.name, file.size, 'bytes');
                setUploadStatus({ type: 'loading', message: `æ­£åœ¨è¯»å–æ–‡ä»¶: ${file.name}...` });
                
                // æ£€æŸ¥ XLSX åº“æ˜¯å¦åŠ è½½
                if (typeof XLSX === 'undefined') {
                    const errorMsg = 'Excel è§£æåº“æœªåŠ è½½ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•';
                    setUploadStatus({ type: 'error', message: errorMsg });
                    console.error('XLSX åº“æœªå®šä¹‰');
                    setTimeout(() => setUploadStatus({ type: 'idle', message: '' }), 5000);
                    return;
                }

                const reader = new FileReader();
                
                reader.onerror = (error) => {
                    console.error('æ–‡ä»¶è¯»å–é”™è¯¯:', error);
                    const errorMsg = 'æ–‡ä»¶è¯»å–å¤±è´¥ï¼Œè¯·é‡è¯•';
                    setUploadStatus({ type: 'error', message: errorMsg });
                    setTimeout(() => setUploadStatus({ type: 'idle', message: '' }), 5000);
                };
                
                reader.onprogress = (event) => {
                    if (event.lengthComputable) {
                        const percent = Math.round((event.loaded / event.total) * 100);
                        setUploadStatus({ type: 'loading', message: `æ­£åœ¨è¯»å–æ–‡ä»¶: ${percent}%` });
                    }
                };
                
                reader.onload = (event) => {
                    console.log('æ–‡ä»¶è¯»å–å®Œæˆï¼Œå¼€å§‹è§£æ...');
                    setUploadStatus({ type: 'loading', message: 'æ­£åœ¨è§£æ Excel æ–‡ä»¶...' });
                    
                    try {
                        console.log('æ£€æŸ¥ XLSX:', typeof XLSX);
                        const workbook = XLSX.read(event.target.result, { type: 'binary' });
                        console.log('å·¥ä½œç°¿è¯»å–æˆåŠŸï¼Œå·¥ä½œè¡¨æ•°é‡:', workbook.SheetNames.length);
                        
                        setUploadStatus({ type: 'loading', message: 'æ­£åœ¨å¤„ç†æ•°æ®...' });
                        
                        const sheetName = workbook.SheetNames[0];
                        const sheet = workbook.Sheets[sheetName];
                        const rawData = XLSX.utils.sheet_to_json(sheet);
                        console.log('åŸå§‹æ•°æ®è¡Œæ•°:', rawData.length);
                        console.log('ç¬¬ä¸€è¡Œæ•°æ®ç¤ºä¾‹:', rawData[0]);

                        const processedData = rawData.map((row, index) => {
                            // è·å–å•†å“åç§° - ä¼˜å…ˆåŒ¹é…å®é™…åˆ—å
                            const getName = () => {
                                return row['å•†å“åç§°'] || row['æ ‡é¢˜'] || row['åç§°'] || row['product_name'] || row['name'] || row['å•†å“å'] || row['title'] || '';
                            };
                            // è·å–SKU
                            const getSKU = () => {
                                return row['SKU'] || row['sku'] || row['å•†å“ç¼–ç '] || row['ç¼–ç '] || '';
                            };
                            // è·å–å°ºç  - ç»Ÿä¸€æ ¼å¼åŒ–ä¸º1ä½å°æ•°
                            const getSize = () => {
                                const sizeValue = row['å°ºç '] || row['size'] || row['è§„æ ¼'] || '';
                                if (!sizeValue) return '';
                                
                                // å°è¯•è½¬æ¢ä¸ºæ•°å­—ï¼Œå¦‚æœæ˜¯æ•°å­—åˆ™ä¿ç•™1ä½å°æ•°
                                const numSize = parseFloat(sizeValue);
                                if (!isNaN(numSize)) {
                                    return numSize.toFixed(1);
                                }
                                // å¦‚æœä¸æ˜¯æ•°å­—ï¼Œç›´æ¥è¿”å›åŸå€¼
                                return String(sizeValue);
                            };
                            // è·å–æ•°é‡ - ä¼˜å…ˆåŒ¹é…"å•†å“æ•°é‡"
                            const getQuantity = () => {
                                const qty = row['å•†å“æ•°é‡'] || row['æ•°é‡'] || row['quantity'] || row['é”€é‡'] || row['é”€å”®æ•°é‡'] || 0;
                                return parseInt(qty) || 0;
                            };
                            // è·å–ä»·æ ¼ - ä¼˜å…ˆåŒ¹é…"è®¢å•é‡‘é¢"
                            const getPrice = () => {
                                const price = row['è®¢å•é‡‘é¢'] || row['é‡‘é¢'] || row['price'] || row['å•ä»·'] || row['å•†å“å•ä»·'] || 0;
                                return parseFloat(price) || 0;
                            };
                            // è·å–æ—¥æœŸ - æ”¯æŒExcelæ—¥æœŸæ ¼å¼
                            const getDate = () => {
                                let dateStr = row['åº—é“ºè®¢å•æ—¶é—´'] || row['è®¢å•æ—¶é—´'] || row['date'] || row['æ—¶é—´'] || row['æ—¥æœŸ'] || '';
                                
                                // å¦‚æœæ˜¯Excelæ—¥æœŸæ•°å­—æ ¼å¼ï¼ˆå¦‚ 45965.5260532407ï¼‰
                                if (typeof dateStr === 'number') {
                                    // Excelæ—¥æœŸä»1900å¹´1æœˆ1æ—¥å¼€å§‹è®¡ç®—
                                    const excelEpoch = new Date(1899, 11, 30);
                                    const date = new Date(excelEpoch.getTime() + dateStr * 24 * 60 * 60 * 1000);
                                    if (!isNaN(date.getTime())) {
                                        return date;
                                    }
                                }
                                
                                if (dateStr) {
                                    // å°è¯•è§£ææ—¥æœŸå­—ç¬¦ä¸²
                                    const date = new Date(dateStr);
                                    if (isNaN(date.getTime())) {
                                        console.warn('æ—¥æœŸè§£æå¤±è´¥:', dateStr, 'ä½¿ç”¨å½“å‰æ—¥æœŸ');
                                        return new Date();
                                    }
                                    return date;
                                }
                                return new Date();
                            };

                            const name = getName();
                            const sku = getSKU();
                            const quantity = getQuantity();
                            
                            return {
                                style: name,
                                sku: sku,
                                color: parseColor(sku),
                                size: String(getSize()),
                                quantity: quantity,
                                price: getPrice(),
                                date: getDate(),
                                revenue: quantity * getPrice()
                            };
                        }).filter(item => {
                            // åªè¦æœ‰å•†å“åç§°ï¼ˆæ ‡é¢˜ï¼‰å’Œæ•°é‡å¤§äº0å°±ä¿ç•™
                            const valid = item.style && item.quantity > 0;
                            if (!valid) {
                                console.warn('è¿‡æ»¤æ‰æ— æ•ˆæ•°æ®:', item);
                            }
                            return valid;
                        });

                        console.log('å¤„ç†åçš„æ•°æ®è¡Œæ•°:', processedData.length);
                        if (processedData.length === 0) {
                            const errorMsg = `æ–‡ä»¶ä¸­æ²¡æœ‰æœ‰æ•ˆæ•°æ®ã€‚\n\néœ€è¦çš„åˆ—ï¼šå•†å“åç§°ã€æ•°é‡ï¼ˆæˆ–é”€é‡ï¼‰\n\nå®é™…åˆ—åï¼š${rawData.length > 0 ? Object.keys(rawData[0]).join(', ') : 'æ— æ•°æ®'}`;
                            setUploadStatus({ type: 'error', message: errorMsg });
                            console.log('åŸå§‹æ•°æ®åˆ—å:', rawData.length > 0 ? Object.keys(rawData[0]) : 'æ— æ•°æ®');
                            setTimeout(() => setUploadStatus({ type: 'idle', message: '' }), 8000);
                            return;
                        }

                        console.log('è®¾ç½®æ•°æ®åˆ°çŠ¶æ€...');
                        setData(processedData);
                        setUploadStatus({ type: 'success', message: `æˆåŠŸåŠ è½½ ${processedData.length} æ¡æ•°æ®ï¼` });
                        console.log('æ•°æ®è®¾ç½®å®Œæˆï¼Œæ•°æ®è¡Œæ•°:', processedData.length);
                        
                        // 3ç§’åæ¸…é™¤æˆåŠŸæ¶ˆæ¯
                        setTimeout(() => setUploadStatus({ type: 'idle', message: '' }), 3000);
                    } catch (error) {
                        console.error('æ–‡ä»¶è§£æé”™è¯¯:', error);
                        console.error('é”™è¯¯å †æ ˆ:', error.stack);
                        const errorMsg = `æ–‡ä»¶è§£æå¤±è´¥ï¼š${error.message}`;
                        setUploadStatus({ type: 'error', message: errorMsg });
                        setTimeout(() => setUploadStatus({ type: 'idle', message: '' }), 8000);
                    }
                };
                
                console.log('å¼€å§‹è¯»å–æ–‡ä»¶...');
                reader.readAsBinaryString(file);
            };

            // è·å–ç­›é€‰é€‰é¡¹
            const filterOptions = useMemo(() => {
                if (!data || data.length === 0) {
                    return {
                        styles: [],
                        colors: [],
                        sizes: []
                    };
                }
                return {
                    styles: [...new Set(data.map(d => d.style).filter(s => s))].sort(),
                    colors: [...new Set(data.map(d => d.color).filter(c => c))].sort(),
                    sizes: [...new Set(data.map(d => d.size).filter(s => s))].sort()
                };
            }, [data]);

            // åº”ç”¨ç­›é€‰
            const filteredData = useMemo(() => {
                return data.filter(item => {
                    if (filters.style && item.style !== filters.style) return false;
                    if (filters.color && item.color !== filters.color) return false;
                    if (filters.size && item.size !== filters.size) return false;
                    if (filters.startDate && item.date < new Date(filters.startDate)) return false;
                    if (filters.endDate && item.date > new Date(filters.endDate)) return false;
                    return true;
                });
            }, [data, filters]);

            // æ ¼å¼åŒ–æ—¥æœŸ
            const formatDate = (date, granularity) => {
                const d = new Date(date);
                if (granularity === 'day') {
                    return `${d.getMonth() + 1}/${d.getDate()}`;
                } else if (granularity === 'week') {
                    const weekNum = Math.ceil((d.getDate()) / 7);
                    return `${d.getMonth() + 1}æœˆç¬¬${weekNum}å‘¨`;
                } else {
                    return `${d.getFullYear()}/${d.getMonth() + 1}`;
                }
            };

            // è®¡ç®—æ—¶é—´è¶‹åŠ¿æ•°æ®
            const trendData = useMemo(() => {
                const grouped = {};
                filteredData.forEach(item => {
                    const key = formatDate(item.date, filters.timeGranularity);
                    if (!grouped[key]) {
                        grouped[key] = { date: key, quantity: 0, revenue: 0 };
                    }
                    grouped[key].quantity += item.quantity;
                    grouped[key].revenue += item.revenue;
                });
                return Object.values(grouped).sort((a, b) => {
                    const aDate = a.date.split(/[/æœˆå‘¨å¹´]/);
                    const bDate = b.date.split(/[/æœˆå‘¨å¹´]/);
                    return aDate[0] - bDate[0] || (aDate[1] || 0) - (bDate[1] || 0);
                });
            }, [filteredData, filters.timeGranularity]);

            // æŒ‰æ¬¾å¼ç»Ÿè®¡
            const styleData = useMemo(() => {
                const grouped = {};
                filteredData.forEach(item => {
                    if (!grouped[item.style]) {
                        grouped[item.style] = { name: item.style, quantity: 0, revenue: 0 };
                    }
                    grouped[item.style].quantity += item.quantity;
                    grouped[item.style].revenue += item.revenue;
                });
                return Object.values(grouped).sort((a, b) => b.quantity - a.quantity).slice(0, 10);
            }, [filteredData]);

            // æŒ‰é¢œè‰²ç»Ÿè®¡
            const colorData = useMemo(() => {
                const grouped = {};
                filteredData.forEach(item => {
                    if (!grouped[item.color]) {
                        grouped[item.color] = { name: item.color, quantity: 0 };
                    }
                    grouped[item.color].quantity += item.quantity;
                });
                return Object.values(grouped).sort((a, b) => b.quantity - a.quantity);
            }, [filteredData]);

            // æŒ‰å°ºç ç»Ÿè®¡
            const sizeData = useMemo(() => {
                const grouped = {};
                filteredData.forEach(item => {
                    if (!grouped[item.size]) {
                        grouped[item.size] = { name: item.size, quantity: 0 };
                    }
                    grouped[item.size].quantity += item.quantity;
                });
                return Object.values(grouped).sort((a, b) => {
                    const aNum = parseFloat(a.name) || 0;
                    const bNum = parseFloat(b.name) || 0;
                    return aNum - bNum;
                });
            }, [filteredData]);

            // è®¡ç®—ç»Ÿè®¡æ•°æ®
            const stats = useMemo(() => {
                const totalQuantity = filteredData.reduce((sum, item) => sum + item.quantity, 0);
                const totalRevenue = filteredData.reduce((sum, item) => sum + item.revenue, 0);
                const avgPrice = totalQuantity > 0 ? totalRevenue / totalQuantity : 0;
                
                let daysDiff = 1;
                
                // å¦‚æœç­›é€‰å™¨ä¸­è®¾ç½®äº†å¼€å§‹æ—¥æœŸå’Œç»“æŸæ—¥æœŸï¼Œä½¿ç”¨ç­›é€‰æ—¥æœŸèŒƒå›´
                if (filters.startDate && filters.endDate) {
                    const startDate = new Date(filters.startDate);
                    const endDate = new Date(filters.endDate);
                    daysDiff = (endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24) + 1;
                } else {
                    // é»˜è®¤æƒ…å†µï¼šä½¿ç”¨å®é™…æ•°æ®çš„æ—¥æœŸèŒƒå›´ï¼ˆæ–¹æ¡ˆäºŒï¼‰
                    const dates = filteredData.map(d => d.date.getTime());
                    if (dates.length > 0) {
                        daysDiff = (Math.max(...dates) - Math.min(...dates)) / (1000 * 60 * 60 * 24) + 1;
                    }
                }
                
                const velocity = totalQuantity / daysDiff;

                return {
                    totalQuantity,
                    totalRevenue,
                    avgPrice,
                    velocity,
                    orderCount: filteredData.length
                };
            }, [filteredData, filters.startDate, filters.endDate]);

            // å¯¼å‡ºPDF
            const exportPDF = async () => {
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF('p', 'mm', 'a4');
                const pageWidth = pdf.internal.pageSize.getWidth();
                
                pdf.setFontSize(20);
                pdf.text('é”€é‡åˆ†ææŠ¥å‘Š', pageWidth / 2, 20, { align: 'center' });
                
                pdf.setFontSize(12);
                let yPos = 35;
                pdf.text(`æ€»é”€é‡: ${stats.totalQuantity} ä»¶`, 20, yPos);
                pdf.text(`æ€»é”€å”®é¢: â‚¬${stats.totalRevenue.toFixed(2)}`, 20, yPos + 7);
                pdf.text(`å¹³å‡å•ä»·: â‚¬${stats.avgPrice.toFixed(2)}`, 20, yPos + 14);
                pdf.text(`é”€å”®æµé€Ÿ: ${stats.velocity.toFixed(2)} ä»¶/å¤©`, 20, yPos + 21);
                
                const charts = document.querySelectorAll('.chart-container');
                yPos = 70;
                
                for (let i = 0; i < charts.length; i++) {
                    if (yPos > 250) {
                        pdf.addPage();
                        yPos = 20;
                    }
                    
                    try {
                        const canvas = await html2canvas(charts[i], { scale: 2 });
                        const imgData = canvas.toDataURL('image/png');
                        const imgWidth = pageWidth - 40;
                        const imgHeight = (canvas.height * imgWidth) / canvas.width;
                        
                        pdf.addImage(imgData, 'PNG', 20, yPos, imgWidth, imgHeight);
                        yPos += imgHeight + 10;
                    } catch (error) {
                        console.error('å›¾è¡¨å¯¼å‡ºå¤±è´¥:', error);
                    }
                }
                
                pdf.save(`é”€é‡åˆ†ææŠ¥å‘Š_${new Date().toLocaleDateString()}.pdf`);
            };

            // åˆ›å»ºå›¾æ ‡ç»„ä»¶ï¼ˆç®€åŒ–ç‰ˆï¼Œä½¿ç”¨SVGï¼‰
            const UploadIcon = () => React.createElement('svg', { width: 24, height: 24, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: 2 },
                React.createElement('path', { d: 'M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4' }),
                React.createElement('polyline', { points: '17 8 12 3 7 8' }),
                React.createElement('line', { x1: 12, y1: 3, x2: 12, y2: 15 })
            );

            const FilterIcon = () => React.createElement('svg', { width: 20, height: 20, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: 2 },
                React.createElement('polygon', { points: '22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3' })
            );

            const DownloadIcon = () => React.createElement('svg', { width: 20, height: 20, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: 2 },
                React.createElement('path', { d: 'M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4' }),
                React.createElement('polyline', { points: '7 10 12 15 17 10' }),
                React.createElement('line', { x1: 12, y1: 15, x2: 12, y2: 3 })
            );

            const XIcon = () => React.createElement('svg', { width: 20, height: 20, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: 2 },
                React.createElement('line', { x1: 18, y1: 6, x2: 6, y2: 18 }),
                React.createElement('line', { x1: 6, y1: 6, x2: 18, y2: 18 })
            );

            const PackageIcon = () => React.createElement('svg', { width: 24, height: 24, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: 2 },
                React.createElement('line', { x1: 16.5, y1: 9.4, x2: 7.5, y2: 4.21 }),
                React.createElement('path', { d: 'M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z' }),
                React.createElement('polyline', { points: '3.27 6.96 12 12.01 20.73 6.96' }),
                React.createElement('line', { x1: 12, y1: 22.08, x2: 12, y2: 12 })
            );

            const DollarSignIcon = () => React.createElement('svg', { width: 24, height: 24, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: 2 },
                React.createElement('line', { x1: 12, y1: 1, x2: 12, y2: 23 }),
                React.createElement('path', { d: 'M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6' })
            );

            const TrendingUpIcon = () => React.createElement('svg', { width: 24, height: 24, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: 2 },
                React.createElement('polyline', { points: '23 6 13.5 15.5 8.5 10.5 1 18' }),
                React.createElement('polyline', { points: '17 6 23 6 23 12' })
            );

            const CalendarIcon = () => React.createElement('svg', { width: 24, height: 24, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: 2 },
                React.createElement('rect', { x: 3, y: 4, width: 18, height: 18, rx: 2, ry: 2 }),
                React.createElement('line', { x1: 16, y1: 2, x2: 16, y2: 6 }),
                React.createElement('line', { x1: 8, y1: 2, x2: 8, y2: 6 }),
                React.createElement('line', { x1: 3, y1: 10, x2: 21, y2: 10 })
            );

            return React.createElement('div', { 
                style: { 
                    minHeight: '100vh', 
                    background: '#ffffff', 
                    color: '#1e293b', 
                    padding: '32px' 
                } 
            },
                React.createElement('div', { style: { maxWidth: '1280px', margin: '0 auto' } },
                    // å¤´éƒ¨
                    React.createElement('div', { style: { marginBottom: '32px' } },
                        React.createElement('h1', { 
                            style: { 
                                fontSize: '2.25rem', 
                                fontWeight: 'bold', 
                                marginBottom: '8px',
                                color: '#1e293b'
                            } 
                        }, 'å•†å“é”€é‡åˆ†æç³»ç»Ÿ'),
                        React.createElement('p', { style: { color: '#64748b' } }, 'æ•°æ®é©±åŠ¨å†³ç­–ï¼Œæ´å¯Ÿé”€å”®è¶‹åŠ¿')
                    ),

                    // ä¸Šä¼ çŠ¶æ€æç¤º
                    uploadStatus.type !== 'idle' && React.createElement('div', {
                        style: {
                            marginBottom: '24px',
                            padding: '16px 24px',
                            borderRadius: '12px',
                            backdropFilter: 'blur(16px)',
                            background: uploadStatus.type === 'error' 
                                ? 'rgba(239, 68, 68, 0.2)' 
                                : uploadStatus.type === 'success'
                                ? 'rgba(16, 185, 129, 0.2)'
                                : 'rgba(59, 130, 246, 0.2)',
                            border: `1px solid ${uploadStatus.type === 'error' 
                                ? 'rgba(239, 68, 68, 0.5)' 
                                : uploadStatus.type === 'success'
                                ? 'rgba(16, 185, 129, 0.5)'
                                : 'rgba(59, 130, 246, 0.5)'}`,
                            display: 'flex',
                            alignItems: 'center',
                            gap: '12px',
                            color: uploadStatus.type === 'error' ? '#dc2626' : uploadStatus.type === 'success' ? '#059669' : '#1e40af'
                        }
                    },
                        uploadStatus.type === 'loading' && React.createElement('div', {
                            style: {
                                width: '20px',
                                height: '20px',
                                border: '3px solid rgba(255, 255, 255, 0.3)',
                                borderTop: '3px solid white',
                                borderRadius: '50%',
                                animation: 'spin 1s linear infinite'
                            }
                        }),
                        uploadStatus.type === 'error' && React.createElement('span', { style: { fontSize: '20px' } }, 'âŒ'),
                        uploadStatus.type === 'success' && React.createElement('span', { style: { fontSize: '20px' } }, 'âœ…'),
                        React.createElement('div', { style: { flex: 1 } },
                            React.createElement('p', { 
                                style: { 
                                    margin: 0, 
                                    fontWeight: uploadStatus.type === 'error' ? '600' : '500',
                                    whiteSpace: 'pre-line'
                                } 
                            }, uploadStatus.message)
                        )
                    ),

                    // ä¸Šä¼ åŒºåŸŸ
                    data.length === 0 && React.createElement('div', { 
                        style: { 
                            backdropFilter: 'blur(16px)', 
                            background: 'rgba(255, 255, 255, 0.9)', 
                            borderRadius: '16px', 
                            border: '1px solid rgba(0, 0, 0, 0.1)', 
                            padding: '48px', 
                            textAlign: 'center', 
                            marginBottom: '32px',
                            transition: 'all 0.3s'
                        } 
                    },
                        React.createElement(UploadIcon),
                        React.createElement('h3', { style: { fontSize: '1.25rem', fontWeight: '600', marginTop: '16px', marginBottom: '8px' } }, 'ä¸Šä¼ Excelæ–‡ä»¶'),
                        React.createElement('p', { style: { color: '#64748b', marginBottom: '16px' } }, 'æ”¯æŒ .xlsx, .xls æ ¼å¼'),
                        React.createElement('label', { style: { display: 'inline-block', cursor: 'pointer' } },
                            React.createElement('input', { 
                                type: 'file', 
                                accept: '.xlsx,.xls', 
                                onChange: handleFileUpload, 
                                style: { display: 'none' } 
                            }),
                            React.createElement('span', { 
                                style: { 
                                    display: 'inline-block',
                                    padding: '12px 24px', 
                                    background: 'linear-gradient(to right, #3b82f6, #8b5cf6)', 
                                    borderRadius: '8px', 
                                    fontWeight: '600',
                                    transition: 'all 0.3s'
                                } 
                            }, 'é€‰æ‹©æ–‡ä»¶')
                        )
                    ),

                    // æ•°æ®å±•ç¤ºåŒº
                    data.length > 0 && React.createElement(React.Fragment, null,
                        // æ“ä½œæ 
                        React.createElement('div', { style: { display: 'flex', gap: '16px', marginBottom: '24px' } },
                            React.createElement('button', {
                                onClick: () => setShowFilters(!showFilters),
                                style: {
                                    display: 'flex',
                                    alignItems: 'center',
                                    gap: '8px',
                                    padding: '8px 16px',
                                    backdropFilter: 'blur(16px)',
                                    background: 'rgba(255, 255, 255, 0.1)',
                                    borderRadius: '8px',
                                    border: '1px solid rgba(255, 255, 255, 0.2)',
                                    color: '#1e293b',
                                    cursor: 'pointer',
                                    transition: 'all 0.3s'
                                }
                            }, React.createElement(FilterIcon), 'ç­›é€‰å™¨'),
                            React.createElement('button', {
                                onClick: exportPDF,
                                style: {
                                    display: 'flex',
                                    alignItems: 'center',
                                    gap: '8px',
                                    padding: '8px 16px',
                                    background: 'linear-gradient(to right, #10b981, #059669)',
                                    borderRadius: '8px',
                                    color: '#1e293b',
                                    border: 'none',
                                    cursor: 'pointer',
                                    transition: 'all 0.3s'
                                }
                            }, React.createElement(DownloadIcon), 'å¯¼å‡ºPDF'),
                            React.createElement('label', {
                                style: {
                                    display: 'flex',
                                    alignItems: 'center',
                                    gap: '8px',
                                    padding: '8px 16px',
                                    backdropFilter: 'blur(16px)',
                                    background: 'rgba(255, 255, 255, 0.1)',
                                    borderRadius: '8px',
                                    border: '1px solid rgba(255, 255, 255, 0.2)',
                                    color: '#1e293b',
                                    cursor: 'pointer',
                                    transition: 'all 0.3s'
                                }
                            },
                                React.createElement(UploadIcon),
                                'é‡æ–°ä¸Šä¼ ',
                                React.createElement('input', { 
                                    type: 'file', 
                                    accept: '.xlsx,.xls', 
                                    onChange: handleFileUpload, 
                                    style: { display: 'none' } 
                                })
                            )
                        ),

                        // ç­›é€‰é¢æ¿
                        showFilters && React.createElement('div', { 
                            style: { 
                                backdropFilter: 'blur(16px)', 
                                background: 'rgba(255, 255, 255, 0.1)', 
                                borderRadius: '16px', 
                                border: '1px solid rgba(255, 255, 255, 0.2)', 
                                padding: '24px', 
                                marginBottom: '24px' 
                            } 
                        },
                            React.createElement('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '16px' } },
                                React.createElement('h3', { style: { fontSize: '1.25rem', fontWeight: '600' } }, 'ç­›é€‰æ¡ä»¶'),
                                React.createElement('button', {
                                    onClick: () => setShowFilters(false),
                                    style: {
                                        background: 'transparent',
                                        border: 'none',
                                        color: '#1e293b',
                                        cursor: 'pointer',
                                        padding: '4px'
                                    }
                                }, React.createElement(XIcon))
                            ),
                            React.createElement('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '16px', marginBottom: '16px' } },
                                React.createElement('div', null,
                                    React.createElement('label', { style: { display: 'block', fontSize: '0.875rem', marginBottom: '8px' } }, 'æ¬¾å¼'),
                                    React.createElement('select', {
                                        value: filters.style,
                                        onChange: (e) => setFilters({...filters, style: e.target.value}),
                                        style: {
                                            width: '100%',
                                            padding: '8px 12px',
                                            background: '#f8fafc',
                                            border: '1px solid #e2e8f0',
                                            borderRadius: '8px',
                                            color: '#1e293b',
                                            outline: 'none'
                                        }
                                    },
                                        React.createElement('option', { value: '' }, 'å…¨éƒ¨æ¬¾å¼'),
                                        ...filterOptions.styles.map(s => React.createElement('option', { key: s, value: s }, s))
                                    )
                                ),
                                React.createElement('div', null,
                                    React.createElement('label', { style: { display: 'block', fontSize: '0.875rem', marginBottom: '8px' } }, 'é¢œè‰²'),
                                    React.createElement('select', {
                                        value: filters.color,
                                        onChange: (e) => setFilters({...filters, color: e.target.value}),
                                        style: {
                                            width: '100%',
                                            padding: '8px 12px',
                                            background: '#f8fafc',
                                            border: '1px solid #e2e8f0',
                                            borderRadius: '8px',
                                            color: '#1e293b',
                                            outline: 'none'
                                        }
                                    },
                                        React.createElement('option', { value: '' }, 'å…¨éƒ¨é¢œè‰²'),
                                        ...filterOptions.colors.map(c => React.createElement('option', { key: c, value: c }, c))
                                    )
                                ),
                                React.createElement('div', null,
                                    React.createElement('label', { style: { display: 'block', fontSize: '0.875rem', marginBottom: '8px' } }, 'å°ºç '),
                                    React.createElement('select', {
                                        value: filters.size,
                                        onChange: (e) => setFilters({...filters, size: e.target.value}),
                                        style: {
                                            width: '100%',
                                            padding: '8px 12px',
                                            background: '#f8fafc',
                                            border: '1px solid #e2e8f0',
                                            borderRadius: '8px',
                                            color: '#1e293b',
                                            outline: 'none'
                                        }
                                    },
                                        React.createElement('option', { value: '' }, 'å…¨éƒ¨å°ºç '),
                                        ...filterOptions.sizes.map(s => React.createElement('option', { key: s, value: s }, s))
                                    )
                                )
                            ),
                            React.createElement('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '16px' } },
                                React.createElement('div', null,
                                    React.createElement('label', { style: { display: 'block', fontSize: '0.875rem', marginBottom: '8px' } }, 'å¼€å§‹æ—¥æœŸ'),
                                    React.createElement('input', {
                                        type: 'date',
                                        value: filters.startDate,
                                        onChange: (e) => setFilters({...filters, startDate: e.target.value}),
                                        style: {
                                            width: '100%',
                                            padding: '8px 12px',
                                            background: '#f8fafc',
                                            border: '1px solid #e2e8f0',
                                            borderRadius: '8px',
                                            color: '#1e293b',
                                            outline: 'none'
                                        }
                                    })
                                ),
                                React.createElement('div', null,
                                    React.createElement('label', { style: { display: 'block', fontSize: '0.875rem', marginBottom: '8px' } }, 'ç»“æŸæ—¥æœŸ'),
                                    React.createElement('input', {
                                        type: 'date',
                                        value: filters.endDate,
                                        onChange: (e) => setFilters({...filters, endDate: e.target.value}),
                                        style: {
                                            width: '100%',
                                            padding: '8px 12px',
                                            background: '#f8fafc',
                                            border: '1px solid #e2e8f0',
                                            borderRadius: '8px',
                                            color: '#1e293b',
                                            outline: 'none'
                                        }
                                    })
                                ),
                                React.createElement('div', null,
                                    React.createElement('label', { style: { display: 'block', fontSize: '0.875rem', marginBottom: '8px' } }, 'æ—¶é—´ç²’åº¦'),
                                    React.createElement('select', {
                                        value: filters.timeGranularity,
                                        onChange: (e) => setFilters({...filters, timeGranularity: e.target.value}),
                                        style: {
                                            width: '100%',
                                            padding: '8px 12px',
                                            background: '#f8fafc',
                                            border: '1px solid #e2e8f0',
                                            borderRadius: '8px',
                                            color: '#1e293b',
                                            outline: 'none'
                                        }
                                    },
                                        React.createElement('option', { value: 'day' }, 'æŒ‰å¤©'),
                                        React.createElement('option', { value: 'week' }, 'æŒ‰å‘¨'),
                                        React.createElement('option', { value: 'month' }, 'æŒ‰æœˆ')
                                    )
                                )
                            ),
                            React.createElement('button', {
                                onClick: () => setFilters({style: '', color: '', size: '', startDate: '', endDate: '', timeGranularity: 'day'}),
                                style: {
                                    marginTop: '16px',
                                    padding: '8px 16px',
                                    background: 'rgba(255, 255, 255, 0.1)',
                                    borderRadius: '8px',
                                    border: 'none',
                                    color: '#1e293b',
                                    cursor: 'pointer'
                                }
                            }, 'æ¸…é™¤ç­›é€‰')
                        ),

                        // ç»Ÿè®¡å¡ç‰‡
                        React.createElement('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))', gap: '24px', marginBottom: '32px' } },
                            React.createElement('div', { 
                                style: { 
                                    backdropFilter: 'blur(16px)', 
                                    background: 'linear-gradient(135deg, rgba(59, 130, 246, 0.2), rgba(37, 99, 235, 0.2))', 
                                    borderRadius: '16px', 
                                    border: '1px solid rgba(96, 165, 250, 0.3)', 
                                    padding: '24px' 
                                } 
                            },
                                React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '12px', marginBottom: '8px' } },
                                    React.createElement(PackageIcon),
                                    React.createElement('h3', { style: { color: '#64748b' } }, 'æ€»é”€é‡')
                                ),
                                React.createElement('p', { style: { fontSize: '1.875rem', fontWeight: 'bold' } }, stats.totalQuantity),
                                React.createElement('p', { style: { fontSize: '0.875rem', color: '#64748b', marginTop: '4px' } }, 'ä»¶')
                            ),
                            React.createElement('div', { 
                                style: { 
                                    backdropFilter: 'blur(16px)', 
                                    background: 'linear-gradient(135deg, rgba(16, 185, 129, 0.2), rgba(5, 150, 105, 0.2))', 
                                    borderRadius: '16px', 
                                    border: '1px solid rgba(16, 185, 129, 0.3)', 
                                    padding: '24px' 
                                } 
                            },
                                React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '12px', marginBottom: '8px' } },
                                    React.createElement(DollarSignIcon),
                                    React.createElement('h3', { style: { color: '#64748b' } }, 'æ€»é”€å”®é¢')
                                ),
                                React.createElement('p', { style: { fontSize: '1.875rem', fontWeight: 'bold' } }, `â‚¬${stats.totalRevenue.toFixed(2)}`),
                                React.createElement('p', { style: { fontSize: '0.875rem', color: '#64748b', marginTop: '4px' } }, 'æ¬§å…ƒ')
                            ),
                            React.createElement('div', { 
                                style: { 
                                    backdropFilter: 'blur(16px)', 
                                    background: 'linear-gradient(135deg, rgba(139, 92, 246, 0.2), rgba(124, 58, 237, 0.2))', 
                                    borderRadius: '16px', 
                                    border: '1px solid rgba(167, 139, 250, 0.3)', 
                                    padding: '24px' 
                                } 
                            },
                                React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '12px', marginBottom: '8px' } },
                                    React.createElement(TrendingUpIcon),
                                    React.createElement('h3', { style: { color: '#64748b' } }, 'å¹³å‡å•ä»·')
                                ),
                                React.createElement('p', { style: { fontSize: '1.875rem', fontWeight: 'bold' } }, `â‚¬${stats.avgPrice.toFixed(2)}`),
                                React.createElement('p', { style: { fontSize: '0.875rem', color: '#64748b', marginTop: '4px' } }, 'æ¬§å…ƒ/ä»¶')
                            ),
                            React.createElement('div', { 
                                style: { 
                                    backdropFilter: 'blur(16px)', 
                                    background: 'linear-gradient(135deg, rgba(249, 115, 22, 0.2), rgba(234, 88, 12, 0.2))', 
                                    borderRadius: '16px', 
                                    border: '1px solid rgba(251, 146, 60, 0.3)', 
                                    padding: '24px' 
                                } 
                            },
                                React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '12px', marginBottom: '8px' } },
                                    React.createElement(CalendarIcon),
                                    React.createElement('h3', { style: { color: '#64748b' } }, 'é”€å”®æµé€Ÿ')
                                ),
                                React.createElement('p', { style: { fontSize: '1.875rem', fontWeight: 'bold' } }, stats.velocity.toFixed(2)),
                                React.createElement('p', { style: { fontSize: '0.875rem', color: '#64748b', marginTop: '4px' } }, 'ä»¶/å¤©')
                            )
                        ),

                        // å›¾è¡¨åŒºåŸŸ
                        React.createElement('div', { style: { display: 'flex', flexDirection: 'column', gap: '24px' } },
                            // é”€é‡è¶‹åŠ¿å›¾
                            React.createElement('div', { 
                                className: 'chart-container',
                                style: { 
                                    backdropFilter: 'blur(16px)', 
                                    background: 'rgba(255, 255, 255, 0.1)', 
                                    borderRadius: '16px', 
                                    border: '1px solid rgba(255, 255, 255, 0.2)', 
                                    padding: '24px' 
                                } 
                            },
                                React.createElement('h3', { style: { fontSize: '1.25rem', fontWeight: '600', marginBottom: '16px' } }, 'é”€é‡è¶‹åŠ¿'),
                                React.createElement('div', { style: { width: '100%', display: 'flex', justifyContent: 'center' } },
                                    React.createElement(CanvasLineChart, { 
                                        data: trendData.map(d => ({ date: d.date, quantity: d.quantity })), 
                                        width: 800, 
                                        height: 300, 
                                        color: '#3b82f6', 
                                        label: 'é”€é‡' 
                                    })
                                )
                            ),

                            // é”€å”®é¢è¶‹åŠ¿å›¾
                            React.createElement('div', { 
                                className: 'chart-container',
                                style: { 
                                    backdropFilter: 'blur(16px)', 
                                    background: 'rgba(255, 255, 255, 0.1)', 
                                    borderRadius: '16px', 
                                    border: '1px solid rgba(255, 255, 255, 0.2)', 
                                    padding: '24px' 
                                } 
                            },
                                React.createElement('h3', { style: { fontSize: '1.25rem', fontWeight: '600', marginBottom: '16px' } }, 'é”€å”®é¢è¶‹åŠ¿'),
                                React.createElement('div', { style: { width: '100%', display: 'flex', justifyContent: 'center' } },
                                    React.createElement(CanvasLineChart, { 
                                        data: trendData.map(d => ({ date: d.date, revenue: d.revenue })), 
                                        width: 800, 
                                        height: 300, 
                                        color: '#10b981', 
                                        label: 'é”€å”®é¢' 
                                    })
                                )
                            ),

                            // æ¬¾å¼é”€é‡
                            React.createElement('div', { 
                                className: 'chart-container',
                                style: { 
                                    backdropFilter: 'blur(16px)', 
                                    background: 'rgba(255, 255, 255, 0.1)', 
                                    borderRadius: '16px', 
                                    border: '1px solid rgba(255, 255, 255, 0.2)', 
                                    padding: '24px' 
                                } 
                            },
                                React.createElement('h3', { style: { fontSize: '1.25rem', fontWeight: '600', marginBottom: '16px', color: '#1e293b' } }, 'æ¬¾å¼é”€é‡æ’è¡Œï¼ˆTop 10ï¼‰'),
                                React.createElement('div', { style: { width: '100%', display: 'flex', justifyContent: 'center', overflowX: 'auto' } },
                                    React.createElement(CanvasBarChart, { 
                                        data: styleData, 
                                        width: 1000, 
                                        height: 400, 
                                        color: '#8b5cf6', 
                                        label: 'é”€é‡',
                                        horizontal: true
                                    })
                                )
                            ),

                            // é¢œè‰²é”€é‡
                            React.createElement('div', { 
                                className: 'chart-container',
                                style: { 
                                    backdropFilter: 'blur(16px)', 
                                    background: 'rgba(255, 255, 255, 0.9)', 
                                    borderRadius: '16px', 
                                    border: '1px solid rgba(0, 0, 0, 0.1)', 
                                    padding: '24px' 
                                } 
                            },
                                React.createElement('h3', { style: { fontSize: '1.25rem', fontWeight: '600', marginBottom: '16px', color: '#1e293b' } }, 'é¢œè‰²é”€é‡åˆ†å¸ƒ'),
                                React.createElement('div', { style: { width: '100%', display: 'flex', justifyContent: 'center' } },
                                    React.createElement(CanvasPieChart, { 
                                        data: colorData, 
                                        width: 700, 
                                        height: 500
                                    })
                                )
                            ),

                            // å°ºç é”€é‡
                            React.createElement('div', { 
                                className: 'chart-container',
                                style: { 
                                    backdropFilter: 'blur(16px)', 
                                    background: 'rgba(255, 255, 255, 0.9)', 
                                    borderRadius: '16px', 
                                    border: '1px solid rgba(0, 0, 0, 0.1)', 
                                    padding: '24px' 
                                } 
                            },
                                React.createElement('h3', { style: { fontSize: '1.25rem', fontWeight: '600', marginBottom: '16px', color: '#1e293b' } }, 'å°ºç é”€é‡åˆ†å¸ƒ'),
                                React.createElement('div', { style: { width: '100%', display: 'flex', justifyContent: 'center' } },
                                    React.createElement(CanvasPieChart, { 
                                        data: sizeData, 
                                        width: 700, 
                                        height: 500
                                    })
                                )
                            )
                        )
                    )
                )
            );
        };

        // åˆå§‹åŒ–åˆ†æç³»ç»Ÿ
        function initAnalysisSystem() {
            console.log('å¼€å§‹åˆå§‹åŒ–åˆ†æç³»ç»Ÿ...');
            
            // æ£€æŸ¥ä¾èµ–æ˜¯å¦åŠ è½½
            console.log('æ£€æŸ¥ React:', typeof React !== 'undefined');
            console.log('æ£€æŸ¥ ReactDOM:', typeof ReactDOM !== 'undefined');
            
            if (typeof React === 'undefined') {
                console.error('React æœªåŠ è½½');
                const rootEl = document.getElementById('root');
                if (rootEl) {
                    rootEl.innerHTML = '<div style="padding: 50px; text-align: center; color: white;"><h2>åŠ è½½é”™è¯¯</h2><p>React åº“æœªåŠ è½½ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥</p><p>è¯·æ‰“å¼€æµè§ˆå™¨æ§åˆ¶å°æŸ¥çœ‹è¯¦ç»†é”™è¯¯</p></div>';
                }
                return;
            }
            
            if (typeof ReactDOM === 'undefined') {
                console.error('ReactDOM æœªåŠ è½½');
                const rootEl = document.getElementById('root');
                if (rootEl) {
                    rootEl.innerHTML = '<div style="padding: 50px; text-align: center; color: white;"><h2>åŠ è½½é”™è¯¯</h2><p>ReactDOM åº“æœªåŠ è½½ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥</p></div>';
                }
                return;
            }

            const rootElement = document.getElementById('root');
            if (!rootElement) {
                console.error('æ‰¾ä¸åˆ° root å…ƒç´ ');
                return;
            }

            try {
                console.log('å°è¯•æ¸²æŸ“ç»„ä»¶...');
                // React 18 ä½¿ç”¨ createRoot
                if (ReactDOM.createRoot) {
                    console.log('ä½¿ç”¨ ReactDOM.createRoot');
                    const root = ReactDOM.createRoot(rootElement);
                    root.render(React.createElement(SalesAnalysisSystem));
                    console.log('ç»„ä»¶æ¸²æŸ“å®Œæˆ');
                } else if (ReactDOM.render) {
                    console.log('ä½¿ç”¨ ReactDOM.render');
                    ReactDOM.render(React.createElement(SalesAnalysisSystem), rootElement);
                    console.log('ç»„ä»¶æ¸²æŸ“å®Œæˆ');
                } else {
                    throw new Error('ReactDOM æ–¹æ³•ä¸å¯ç”¨');
                }
            } catch (error) {
                console.error('åˆå§‹åŒ–å¤±è´¥:', error);
                console.error('é”™è¯¯å †æ ˆ:', error.stack);
                rootElement.innerHTML = '<div style="padding: 50px; text-align: center; color: white;"><h2>åˆå§‹åŒ–é”™è¯¯</h2><p>' + error.message + '</p><p>è¯·æ‰“å¼€æµè§ˆå™¨æ§åˆ¶å°æŸ¥çœ‹è¯¦ç»†é”™è¯¯ä¿¡æ¯</p><p>è¯·åˆ·æ–°é¡µé¢é‡è¯•</p></div>';
            }
        }

        // ç­‰å¾…æ‰€æœ‰è„šæœ¬åŠ è½½å®Œæˆåå†åˆå§‹åŒ–
        async function waitForDependencies() {
            console.log('ç­‰å¾…ä¾èµ–åŠ è½½...');
            const hasReact = typeof React !== 'undefined';
            const hasReactDOM = typeof ReactDOM !== 'undefined';
            
            console.log('ä¾èµ–çŠ¶æ€ - React:', hasReact, 'ReactDOM:', hasReactDOM);
            
            // ç­‰å¾… React å’Œ ReactDOM åŠ è½½
            if (!hasReact || !hasReactDOM) {
                console.log('ç­‰å¾…æ ¸å¿ƒä¾èµ–åŠ è½½...');
                // å¦‚æœä¾èµ–æœªåŠ è½½ï¼Œç­‰å¾…ä¸€æ®µæ—¶é—´åé‡è¯•ï¼ˆæœ€å¤šç­‰å¾…10ç§’ï¼‰
                const maxWait = 10000; // 10ç§’
                const startTime = Date.now();
                await new Promise((resolve) => {
                    const checkInterval = setInterval(() => {
                        const hasReactNow = typeof React !== 'undefined';
                        const hasReactDOMNow = typeof ReactDOM !== 'undefined';
                        
                        console.log('æ£€æŸ¥ä¾èµ– - React:', hasReactNow, 'ReactDOM:', hasReactDOMNow);
                        
                        if (hasReactNow && hasReactDOMNow) {
                            clearInterval(checkInterval);
                            console.log('æ ¸å¿ƒä¾èµ–å·²åŠ è½½');
                            resolve();
                        } else if (Date.now() - startTime > maxWait) {
                            clearInterval(checkInterval);
                            console.error('åŠ è½½è¶…æ—¶');
                            const rootEl = document.getElementById('root');
                            if (rootEl) {
                                rootEl.innerHTML = '<div style="padding: 50px; text-align: center; color: white;"><h2>åŠ è½½è¶…æ—¶</h2><p>React æˆ– ReactDOM åŠ è½½æ—¶é—´è¿‡é•¿</p><p>è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥ååˆ·æ–°é¡µé¢</p><p>è¯·æ‰“å¼€æµè§ˆå™¨æ§åˆ¶å°æŸ¥çœ‹è¯¦ç»†é”™è¯¯</p></div>';
                            }
                            resolve();
                        }
                    }, 100);
                });
            }
            
            // ä¸å†éœ€è¦åŠ è½½ Rechartsï¼Œä½¿ç”¨åŸç”Ÿ Canvas
            // ç­‰å¾…ä¸€ä¸‹ç¡®ä¿æ‰€æœ‰è„šæœ¬éƒ½åŠ è½½å®Œæˆ
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // åˆå§‹åŒ–ç³»ç»Ÿ
            console.log('å¼€å§‹åˆå§‹åŒ–ç³»ç»Ÿ');
            initAnalysisSystem();
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', waitForDependencies);
        } else {
            waitForDependencies();
        }
    </script>
</body>
</html>

